## 导航守卫

`vue-router`提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由
导航过程中，全局的、单个路由独享的或组件级别的

**参数或查询的改变并不会触发进入/离开的导航守卫**，你可以通过观察`$store`对象来应对
这些变化，或使用`beforeRouteUpdate`的组件内守卫

### 全局前置守卫

你可以使用`router.beforeEach`注册一个全局前置守卫

```
const router = new VueRouter({})

router.beforeEach((to, from, next) => {

})
```

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在
所有守卫 resolve 完之前一直处于等待中

- `to: Route`即将要进入的目标路由对象

- `from: Route`当前导航正要离开的路由

- `next: Function`一定要调用这个方法来 resolve 这个钩子

  `next()`进行管道中的下一个钩子，如果全部钩子执行完了，则导航的状态是 confirmed（确认的）

  `next(fale)`中断当前的导航。如果浏览器的 URL 改变了，那么 URL 地址会重置到`from`路由对应的地址

  `next('/')`或者`next({path: '/'})`跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。
  你可以想`next`传递任意对象，允许设置诸如`replace: true`、`name: 'home'`之类的选项

  `next(error)`（2.4.0+）如果传入`next`的参数是一个`Error`实例，则导航会被终止且该错误
  会被传递给`router.onError()`注册过的回调

  确保`next`函数在任何给定的导航守卫中都严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径
  都不重叠的情况下，否则钩子永远都不会被解析或报错

  ### 全局解析守卫

  `router.beforeResolve`（2.5.0+）注册一个全局守卫，这和`router.beforeEach`类似，
  区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用

### 全局后置钩子

你也可以注册全局后置钩子，然后和守卫不同的是，这些钩子不会接受`next`函数也不会改变导航本身
