## 模块

从 ES6 开始，JavaScript 引入了模块的概念，TypeScript 也沿用了这个概念

模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量、函数、类等在模块
外部是不可见的，除非你明确地使用`export`形式之一导出它们。相反，如果想使用其它模块导出的变量、函数、类、
接口等的时候，必须要导入它们，使用`import`

模块是自声明的，两个模块之间的关系是通过在文件级别上使用 imports 和 exports 建立的。

模块使用模块加载器去导入其它的模块，在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块
的所有依赖。大家熟知的 JavaScript 模块加载器是服务于 Node.js 的 CommonJS 和服务于 web 应用的 Require.js

TypeScript 与 ES6 一样，任何包含顶级`import`和`export`的文件都被当成一个模块。相反地，如果一个文件不带有
顶级的`import`或者`export`声明，那么它的内容被视为全局可见的。

### 导出

任何声明，比如变量、函数、类、类型别名或接口，都能够通过添加`export`关键字来导出

```ts
export const numberRegexp = /^[0-9]+$/;
```

导出语句很便利，我们可能需要对导出的部分重命名

```ts
class ZipCodeValidator implements StringValidator {
  isAcceptable(s: string) {
    return s.length === 5 && numberRegexp.test(s);
  }
}

export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
```

### 重新导出

我们经常会去扩展其它模块，并且只导出那个模块的部分内容。重新导出功能并不会在当前模块导入那个模块或
定义一个新的局部变量

```ts
export class ParseIntBasedZipCodeValidator {
  isAcceptable(s: string) {
    return s.length === 5 && parseInt(s).toString() === s;
  }
}

// 导出原先验证器但做了重命名
export { ZipCodeValidator as RegexpBasedZipCodeValidator } from "./ZipCodeValidator";
```

或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法`export * from 'module'`

```
export * from './StringValidator'
export * from './LettersOnlyValidator'
export * from './ZipCodeValidator'
```

## 导入

模块导入与导出一样简单，可以使用`import`形式之一来导入其它模块中的导出内容

可对导出内容重命名

```ts
import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";

let myValidator = new ZCV();
```

将整个模块导入到一个变量，并通过它来访问模块的导出部分

```ts
import * as validator from "./ZipCodeValidator";

let myValidator = new validator.ZipCodeValidator();
```

具有副作用的导入模块

尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何导出或用户根本就不关注它的
导出。使用下面的方法来导入这类模块

```ts
import "./my-module.js";
```

## 默认导出

每个模块都可以有一个`default`导出。默认导出使用`default`关键字标记，并且一个模块只能够有一个
`default`导出

类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的

```ts
export default class ZipCodeValidator {
  static numberRegexp = /^[0-9]+$/;
  isAcceptable(s: string) {
    return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);
  }
}
```

Test.ts

```ts
import validator from "./ZipCodeValidator";

let myValidator = new validator();
```

`default`导出也可以是一个值

OneTwoThree.ts

```ts
export default "123";
```

Log.ts

```ts
import num from "OneTwoThree";

console.log(num); // "123"
```

CommonJS 和 AMD 的环境里都有一个`exports`变量，这个变量包含了一个模块所有导出内容。

CommonJS 和 AMD 的`exports`都可以被赋值为一个对象，这种情况下其作用就类似于 ES6 语法里的默认导出。
虽然作用相似，但是 `export default`语法并不能兼容 CommonJS 和 AMD 的`exports`

## 生成模块代码

根据编译时指定的模块目标参数，编译器会生成相应的供 Node.js(CommonJS)，Require.js(AMD)，UMD，SystemJS
或 ES6 native modules 模块加载系统使用的代码

想要了解生成代码中`define`、`require`、`register`的意义，请参考相应模块加载器的文档

## 可选的模块加载和其它高级加载场景

有时候，你只想在某种条件下才加载某个模块。在 TypeScript 里，使用下面的方式实现它和其它的高级加载场景，
我们可以直接调用模块加载器并且可以保证类型完全。

## 使用其它的 JavaScript 库

要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露的 API

我们叫它声明因为它不是"外部程序"的具体实现。它们通常是在`.d.ts`文件里定义的

### 外部模块

在 Node.js 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的`export`声明来为
每个模块都定义一个`.d.ts`文件，但最好还是写在一个大的`.d.ts`文件里。

我们使用与构造一个外部命名空间相似的方法，但是这里使用`module`关键字并且把名字用引号括起来，方便之后`import`

node.d.ts

```ts
declare module "url" {
  export interface Url {
    protocol?: string;
    hostname?: string;
    pathname?: string;
  }

  export function parse(
    urlStr: string,
    parseQueryString?,
    slashesDenoteHost?
  ): Url;
}

declare module "path" {
  export function normalize(p: string): string;
  export function join(...paths: any[]): string;
  export let sep: string;
}
```

现在我们可以`///<reference> node.d.ts`

```ts
/// <reference path="node.d.ts">
import * as URL from "url";

let myUrl = URL.parse("http://www.typescriptlang.org");
```

### 外部模块简写

假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够
快速使用它

declarations.d.ts

```ts
declare module "hot-new-module";
```

简写模块里所有导出的类型将是 `any`

```ts
import x, { y } from "hot-new-module";
x(y);
```

### 模块声明通配符

某些模块加载器如`SystemJS`和`AMD`支持导入非 JavaScript 内容。它们通常会使用一个前缀或后缀来表示特殊的
加载语法。

```ts
declare module "*!text" {
  const content: string;
  export default content;
}

declare module "json!*" {
  const value: any;
  export default value;
}
```
